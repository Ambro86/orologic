scaccologio  todo-list
Voglio creare un programma accessibile che funga da orologio per giocare a scacchi.
Sarà in python, verrà usato 1 tab per indentare, il codice non conterrà righe vuote.
Il nome è Scaccologio e partiamo dalla versione 2.0.0
Useremo solo la console, niente GUI. Ci sarà un menù che conterrà tutte le voci che portano alle varie szioni del programma. Le voci si sceglieranno battendo una o più lettere così come indicato dalla funzione menu di cui riporto la docstring:
def menu(d={}, p="> ", ntf="Scelta non valida", show=False, show_only=False, keyslist=False):
	'''
	V2.0.0 del 13 febbraio 2025
	riceve
		dict d: il menù da mostrare d{'chiave':'spiegazione'}
		str p: prompt per richiesta comandi
		str ntf: da mostrare in caso di comando non presente in d
		bool show: se vero, mostra menù alla chiamata
		bool show_only: se vero mostra menù e ritorna None
		bool keyslist: se vero genera prompt con sequenza di chiavi e ignora p
	ritorna
		str stringa: scelta effettuata
	'''
Per il controllo degli orologi dovremo usare i threads perchè il programma sarà fermo su degli input per ricevere i comandi, ma il flusso del tempo non può essere arrestato.
Per ogni tipo di input useremo questo metodo personalizzato, ecco la docstring:
def dgt(prompt="", kind="s", imin=-999999999, imax=999999999, fmin=-999999999.9, fmax=999999999.9, smin=0, smax=256, pwd=False, default=None):
	'''Versione 1.9 di lunedì 17 aprile 2023
	Potenzia la funzione input implementando controlli di sicurezza.
	Riceve il prompt, il tipo e
	  imin e imax minimo e massimo per i valori interi;
	  fmin e fmax minimo e massimo per i valori float;
	  smin e smax minimo e massimo per la quantità di caratteri nella stringa.
	se il valore e più piccolo di minimo, quest'ultimo viene ritornato, idem per il valore massimo;
	il kind può essere s stringa, i intero e f float;
	se pwd è vera, si chiama getpass per l'inserimento mascherato e non vengono accettati valori fuori dai limiti
	default viene ritornato solo se si preme invio prima di aver fornito un input e se dgt ha ricevuto un valore diverso da None
	'''
useremo python-chess per la gestione della scacchiera, validazione mosse, visualizzazione scacchiera in caratteri ASCII e scrittura del pgn finale.
Il programma sarà corredato da un'ampia gamma di segnali acustici, sia per motivi estetici che di allert. Per i suoni useremo questa funzione:
def Acusticator(score, kind=1, adsr=[0.2, 0.0, 100.0, 0.2], fs=44100, sync=False):
	"""
	V3.2 di domenica 9 febbraio 2025. Gabriele Battaglia e ChatGPT o3-mini-high
	Crea e riproduce (in maniera asincrona) un segnale acustico in base allo score fornito,
	utilizzando simpleaudio per la riproduzione e applicando un envelope ADSR definito in termini
	di percentuali della durata della nota.
	Parametri:
	 - score: lista di valori in multipli di 4, in cui ogni gruppo rappresenta:
	     * nota (string|float): una nota musicale (es. "c4", "c#4"), un valore in Hz oppure "p" per pausa.
	     * dur (float): durata in secondi.
	     * pan (float): panning stereo da -1 (sinistra) a 1 (destra).
	     * vol (float): volume da 0 a 1.
	 - kind (int): tipo di onda (1=sinusoide, 2=quadra, 3=triangolare, 4=dente di sega).
	 - adsr: lista di quattro valori [a, d, s, r] in percentuali (0 a 100) dove:
	         • a = percentuale della durata della nota destinata all'attacco (rampa da 0 a 1),
	         • d = percentuale destinata al decadimento (rampa da 1 al livello di sustain),
	         • s = livello di sustain (valore percentuale volume, che verrà scalato in un numero frazionario da 0 a 1),
	         • r = percentuale destinata al rilascio (rampa da sustain a 0).
	         La fase di sustain occupa il tempo rimanente, cioè: 100 - (a + d + r) in percentuale della durata totale.
	         È richiesto che a + d + r ≤ 100.
	         Il valore di default è [.2, 0.0, 100.0, .2].
	 - fs (int): frequenza di campionamento (default 44100 Hz).
	Se la lunghezza di score non è un multiplo di 4 viene sollevato un errore.
	La riproduzione avviene in background, restituendo subito il controllo al chiamante.
	"""
perciò crea segnalazioni acustiche e piccoli gingle per ogni evento.
Scaccologio si aprirà presentando il suo nome, il numero di versione, la data in cui è stata rilasciata l'ultima versione e il tempo trascorso da tale rilascio in anni, mesi, giorni, minuti ore.
nonché il nome del programmatore Gabriele Battaglia
Poi invieterà a digitare "?" per visualizzare l'l'intero menù.
Il prompt che attende i comandi del menù mostrerà le varie lettere per le scelte così come da specifiche di menu.
Tutte le impostazioni che necessitano di essere salvate e ricaricate useranno un file json che conterrà ogni dato.
Il menù principale avrà, all'inizio queste voci, altre ne verranno aggiunte in futuro:
	? visualizza il menù
	c crea un orologio
	v vedi gli orologi salvati
	d elimina uno degli orologi salvati
	e edita le informazioni che verranno aggiunte di default pal pgn salvato come i tag event, site e altri
	m visualizza il manuale di Scaccologio
	g inizia a giocare.
	. esce dall'applicazione e salva i dati se necessario
Creazione orologio.
Qui viene chiesto il nome dell'orologio che lo definirà fra quelli salvati
Se non ci sono orologi salvati, viene chiesto di creare il primo
Poi si iniziano i parametri di fase 1
Si chiede se bianco e nero debbano partire con lo stesso tempo, invio conferma, tasto n nega.
Se n, viene chiesto l'ammontare del bianco in ore, minuti e incremento, poi quello del nero, altrimenti viene chiesto un solo ammontare ed assegnato ad entrambi i colori.
Poi si chiede il numero di mosse per fase1, se 0 indica che l'orologio avrà solo fase 1.
Se diverso da 0, il ciclo si ripete con fase 2 fino ad un massimo di 4 fasi.
Ora si chiede se inserire allarmi a determinati ammontare di tempo. Se ne possono inserire fino a 5. Tali allarmi stamperanno un messaggio a schermo ed emetteranno un segnale acustico quando l'orologio o bianco o nero, raggiunge il tempo specificato.
Poi viene chiesta una nota che aggiunge info utili a quell'orologio specifico.
Al termine l'orologio e tutte le sue impostazioni viene salvato nel db degli orologi.
Quando si visualizza la lista orologi viene stampata una lista con nome orologio, numero fasi, un indicatore che mostra se bianco e nero hanno lo stesso tempo, ed un riepilogo dei tempi delle fasi con tempi e incrementi. Se presente, sotto all'orologio viene stampata anche la nota relativa.
Quando si sceglie di cancellare un orologio come anche quando si inizia il gioco, il programma mostra la lista degli orologi salvati e l'utente deve sceglierne uno. Per cancellarlo nel primo caso, per usarlo nel gioco, nel secondo. La scelta va fatta passando la lista nomi orologi a menu che così la filtra e la restringe via via che l'utente ne digita parte del nome.
Durante il gioco, un prompt indicherà il numero mossa attuale, 0 prima che il bianco muova e si resterà in attesa di un comando o della notazione algebrica della mossa.
Tutti i comandi saranno preceduti da un . mentre il resto va passato a python-chess come mossa.
I comandi al momento sono:
.1 tempo rimanente al bianco
.2 tempo rimanente al nero
.3 confronto fra tempi, risponderà ad esempio: il nero in vantaggio di 2 minuti 14 secondi
.p mette in pausa gli orologi
Con pausa attiva sarà possibile cancellare l'ultima mossa con .q fino a tornare ad inizio partita.
Sempre soltanto in pausa possono essere modificati gli orologi aggiungengo o sottraendo tempo con i comandi:
.b+### .b-### .n+### .n-###
dove b ed n sono bianco e nero, + e - sono per aggiungere o sottrarre e # sono il numero di secondi.
A conferma dell'avvenuta applicazione della modifica, verrà stampato un messaggio con il nuovo tempo per quel colore.
Quando il tempo è in pausa, la mossa visualizzata nel prompt sarà fra [].
.p rimette in moto gli orologi
in caso di inserimento mosse, queste saranno indicate in SAN e l'orologio scatterà solo se la mossa sarà ritenuta legale, in caso contario il messaggio di mossa illegale ed eventuale altra spiegazione proveniente da python-chess, verrà stampato.
.bianco .nero .patta .* assegnano uno dei possibili 4 risultati.
.s mostra la scacchiera orientata dalla parte di chi ha il turno in quel momento
Si esce dal gioco quando il primo orologio finisce il tempo o su comando .*
Ovviamente l'attribuzione di uno dei 4 risultati, ferma gli orologi. I tempi rimanenti vengono salvati nel pgn con gli appositi tag di remaining time per bianco e nero
Al termine del gioco viene chiesto il nome di entrambi i giocatori, il nome evento, il luogo della partita, il round; mentre i tag date, risultato e Annotator sono compilati autamicamente: quest'ultimo conterrà Scaccologio e sua versione.
Se ci sono dati di default già salvati per questi tag, i campi saranno recompilati e l'utente li accetterà battendo invio.
Poi il pgn con nome nomebianco-nomenero-data_attuale.pgn viene salvato.
Vengono salvati anche evento, site che verranno proposti alla partita successiva così da non doverli digitare di nuovo.
Per ogni istruzione che non risulti chiari, fra quelle fornite, fammi delle domande prima della generazione del codice, in modo da poter procedere avendo risolto prima eventuali ambiguità.
***
1. **Schermata iniziale:** Per la visualizzazione iniziale (nome, versione, data rilascio, tempo trascorso), devo calcolare dinamicamente il tempo trascorso dalla data di rilascio (13 febbraio 2025) rispetto all’orario attuale del sistema oppure utilizzare una data fissa?
R1: prevedi una costante nel codice che ora avrà la data odierna ma che io aggiornerò ogni volta che aumento il numero di versione. Perciò calcola la differenza fra il tempo corrente e quello indicato in questa costante. Puoi usare dateutil.

2. **Funzioni dgt e Acusticator:** Le funzioni `dgt` e `Acusticator` le devo implementare integralmente oppure posso considerarle già disponibili e concentrarmi sul loro utilizzo?
R2: sono già disponibili. Determina come funzionano dalla docstring e passa loro i dati necessari.

3. **Gestione dei thread:** Per controllare i countdown degli orologi, ogni orologio deve avere un thread separato? Come vuoi gestire la pausa e la ripresa: i thread devono essere sospesi/ripresi oppure deve essere implementata una logica diversa?
R3. Scegli tu la soluzione migliore. Io credo che basti un thread per entrambi gli orologi. Quando è attivo il tempo del bianco, quello del nero è fermo, e viceversa. Se la pausa è attiva, sono fermi entrambi. Il thread serve solo perchè il programma sraà fermo sull'input mentre si aspettano comandi e mosse. Il thread può stare aperto per tutta l'esecuzione del programma, poi i countdown possono essere attivati o fermati alla bisogna, senza bisogno di chiudere il thread. Almeno questo è ciò che mi sembra meglio ma se hai idee migliori dimmi pure.

4. **Comandi in partita:**  
   - Confermi che ogni comando in partita viene riconosciuto se preceduto da un punto (`.`) e che, se l’input non inizia con un punto, lo interpreto come mossa in notazione SAN da passare a python‑chess?  
   - Il comando `.p` deve metterli in pausa (ed attivare i comandi di annullamento e aggiustamento) e, digitandolo nuovamente, riprendere il countdown?
R4. Si, confermo, la tua comprensione è perfetta.

5. **Undo mossa (.q):** Vuoi che `.q` annulli l’ultima mossa (e quindi ripristini il tempo precedente) oppure che rimuova solo l’ultimo evento senza modificare il clock? Come deve funzionare esattamente l’annullamento?
R5. deve annullare solo l'ultima mossa. Ci penso io poi ad assegnare eventuali penalità di tempo. Ma alla ripresa con .p, stampa a video per quanto tempo è durata la pausa.

6. **Struttura del file JSON:** Hai già in mente una struttura per salvare gli orologi e le impostazioni default per il PGN oppure preferisci che la progetti in base alle necessità del programma?
R6: progettala come ti sembra meglio ma indica a json di usare 1 solo tab per indentare

7. **Manuale (opzione m):** Quali informazioni devono essere incluse nel manuale di Scaccologio? Vuoi un testo statico che riprenda le funzionalità e i comandi oppure un'altra modalità?
R7: mi serve un README.md che includerò poi nel progetto su github, quindi mi serve un file che spieghi le funzioni di Scaccologio ma di questo possiamo occuparcene in seguito. Vorrei però che l'apertura del manuale fosse demandata al browser o al lettore di default per i file .md.
***
1. Questa costante RELEASE_DATE=datetime.datetime(2025,2,14) non basta perchè voglio anche ora e minuto.
2. C'è una ragione per cui, menu_choices={"?":"Visualizza il menù","c":"Crea un orologio","v":"Vedi gli orologi salvati","d":"Elimina un orologio","e":"Modifica info default per PGN","m":"Visualizza il manuale","g":"Inizia a giocare",".":"Esci dall'applicazione"} debba stare all'all'interno di while ed essere assegnata ad ogni ciclo? Se la risposta è no, spostala fuori e strutturala meglio: una voce per riga, così che si possano aggiungere facilmente nuove voci in futuro.
3. Nel menu, invece di "Scelta", lascia creare a lui la lista come prompt:
		bool keyslist: se vero genera prompt con sequenza di chiavi e ignora p
Sempre nel menu, Usa anche ntf per passare l'errore in caso la scelta non sia nel dizionario.
4. In vedi orologi, usa 2 sole righe per ciascun orologio: la prima con i dati e la seconda per la nota. Usa B=N se il tempo è lo stesso per i 2 colori e B/N se diverso, oppure il simbolo "diverso" al posto di "/". Poi indica le fasi con F1 F2 F3 F4 e, se presenti falle seguire dall'indicazione di tempo impostato per quella fase.
5. Nella richiesta dei tempi, in fase di creazione orologi, chiedi il tempo nel formato hh:mm:ss, non in secondi come ora.
6. Ti mostro come modificare gli import ad inizio:
import sys, os, time, json, threading, datetime, chess, webbrowser
from dateutil.relativedelta import relativedelta
from GBUtils import dgt, menu, Acusticator
7. In fine ho fatto un primo test:
Ho creato un orologio, poi ho premuto g ed ho ottenuto questo:
Traceback (most recent call last):                                                                                                                                                                               
  File "E:\git\Mine\Stuff\scaccologio.py", line 301, in <module>                                                                                                                                                 
    main()                                                                                                                                                                                                       
  File "E:\git\Mine\Stuff\scaccologio.py", line 292, in main                                                                                                                                                     
    index=int(scelta_clock)-1                                                                                                                                                                                    
          ^^^^^^^^^^^^^^^^^                                                                                                                                                                                      
ValueError: invalid literal for int() with base 10: ''                                                                                                                                                           
***
1. Dopo ogni scelta effettuata dal menù. Quando si entra in una diversa sezione del programma, viene stampato un titolo che indica la funzione di quella parte del software.
Ad esempio, l'utente preme "c" e si stampa:
"\nCreazione orologi\n"
Stessa cosa per ogni sezione.
2. Nei dettagli dell'orologio da mostrare, manca l'incremento.
Potresti aggiungere dopo il tempo, un +15, se questo è di 15 secondi e un +0 se non c'è incremento.
3. Quando devo scegliere uno degli orologi, per giocare o per cancellarlo: usa menu passando i nomi degli orologi come dizionario per le scelte e "Scegli orologio iniziando a digitarne il nome" come prompt.
4. premendo la g per giocare, l'app mi dice not enough choice, scelta non valida. Penso ci sia un problema nella scelta degli orologi.
***
Bene, procediamo molto bene.
Una modifica importante:
1. quando mostri i tempi richiesti con .1 .2 .3, il formato di risposta deve essere: 1 ora, 14 minuti, 6 secondi.
Riporta ore minuti secondi, solo se diversi da 0.
2. Nel prompt di gioco, deve essere riportato: progressivo e ultima mossa effettuata, vedi esempio:
14. Ng3 (questa è una mossa del bianco)
14... Qxd4+ (questa è del nero) perchè ci sono "..." dopo il numero mossa.
3. in fase di gioco, con tempi sia in pausa che in moto, il .c seguito da un qualsiasi testo, verrà registrato come commento a quella specifica mossa.
4. Se non l'hai già fatto, imposta una variabile ad inizio file che contiene tutti i comandi preceduti dal punto ed il loro significato.
5. Aggiungi anche il comando .? che visualizzerà una lista di tutti i comandi "." e la loro spiegazione.
Per i punti 4 e 5 puoi usare un dizionario e la funzione menu con il flag show_only.
***
1. C'è un errore nel prompt di gioco: I "..." vengono mostrati nel modo sbagliato. Se io scrivo e4, l'app mostra: "1... e4". Non va bene perchè i "..." si mettono sulla mossa del nero. Quindi sarebbe "1. e4" e poi "1... e5".
2. Al termine della partita, se i nomi dei giocatori vengono restituiti vuoti, imposta come Bianco e Nero.
3. Nel tag Annotator, oltre  ai dati attuali, aggiungi anche il nome del programmatore.
***
1. solo .* assegna risultato e conclude la partita mentre .bianco e .nero non hanno efetto.
2. il tag Event rimane: [Event "Scaccologio Game"], se l'utente accetta il valore di default precompilato alla richiesta.
3. La data non viene più inclusa nel pgn.
4. Richiesta modifica al promtp di gioco: chiedo di mostrare l'ultma mossa. Ora ho solo: 1... se tocca al nero mossa 1. Io voglio questo:
	0. (siamo all'inizio
	e4
	1. e4
	e5
	1... e5
In pratica deve mostrare l'ultima mossa accetata dal sistema che, se è quella del nero deve avere i ...
***
Riprendiamo l'intero codice:

1. verrà usato 1 tab per indentare, il codice non conterrà righe vuote.
2. Facilitazione all'inserimento mosse. chess è piuttosto rigida nell'accettare il SAN, perciò prevedi queste facilitazioni.
le mosse che iniziano con r, n,k q, capitalizzale, cioè rf8 diventa Rf8 affinchè venga accettata. Anche o-o, o-o-o diventano maiuscole, così come 0-0 e 0-0-0, un modo non convenzionale per indicare l'arrocco. ne caso di bc3 deve rimanere diversa da Bc3 perchè una riguarda il pedone, l'altra l'alfiere, quindi qui la maiuscola è importante.
3. .bianco e .nero continuano a non funzionare, osserva:
	2. Nf3 Nf6
	2... Nf6 .bianco
	2... Nf6
Senza che venga assegnato il risultato.
Invece :* e .patta funzionano regolarmente.
4. Modifica il metodo di selezione orologi: crea un dizionario in cui la chiave è un progressivo che parte da uno e il valore è la spiegazione dell'orologio, così come avviene quando li visualizzo. Poi passa il dizionario a menu e metti show=True e keyslist=False, prompt="Scegli dizionario". L'utente sceglierà un numero corrispondente all'orologio usato per giocare o anche da cancellare, se siamo nella sezione per eliminare l'orologi.
5. Nel test ho ottenuto questo pgn:
[Event "Scaccologio Game"]
[Site "?"]
[Date "2025.02.14"]
[Round "?"]

Come vedi, a parte la data, gli altri 3 tags sono tutti sbagliati perchè io avevo indicato valori diversi.
***
1. i tag event, site e round: problema risolto! Ottimo.
2. i comandi .bianco e .nero continuano a non funzionare. Correggi il problema.
	3... Nd7 .bianco                                                                                                                                                                                                 
	3... Nd7 .bianco                                                                                                                                                                                                 
	3... Nd7 .BIANCO                                                                                                                                                                                                 
	3... Nd7 .bianco.                                                                                                                                                                                                
	3... Nd7 .bianco                                                                                                                                                                                                 
	3... Nd7 .BIanco                                                                                                                                                                                                 
***
